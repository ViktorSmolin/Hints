# Big-O — как растёт время/память от размера входа n

- O(1) доступ по индексу, хэш-таблицы (в среднем)
- O(n) линейные обходы (find/includes)
- O(log n) бинарный поиск, сбалансированные деревья
- O(n log n) сортировки (quicksort/merge sort)
- O(n^2) вложенные циклы (наивные сравнения)

# Практика фронта

- Автокомплит, фильтры, списки — линейные операции на десятках тысяч уже ощутимы
- Индексация/дебаунс/веб-воркеры — когда данных много
- Не оптимизируй без измерения: performance.now(), профайлер

# Интервью-вопросы

- Сложность Array.prototype.find? — O(n)
- Когда бинарный поиск лучше? — на отсортированных данных, при частых поисках
- Почему «быстрый сервер» не оправдание? — сеть/браузер/мобильные устройства/масштаб
