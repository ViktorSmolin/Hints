Цель: руками сравнить O(n) vs O(log n), понять когда это важно.

- compare.js — линейный поиск vs бинарный поиск
- Поиграйся с размером массива и измерениями

Разбор кода по частям
Параметры функции:

sortedArr — отсортированный массив, в котором производится поиск

x — искомый элемент

Инициализация переменных:

l (left) — левая граница поиска, начинается с 0

r (right) — правая граница поиска, начинается с последнего индекса массива

Основной цикл:

Работает пока левая граница меньше или равна правой (l <= r)

На каждой итерации:

Вычисляется середина отрезка

Проверяется значение в середине

Корректируются границы поиска

Вычисление середины:

const m = (l + r) >> 1 — используется побитовый сдвиг вправо (эквивалент деления на 2)

Более эффективный способ, чем Math.floor((l + r) / 2)

Логика сравнения:

Если элемент найден (sortedArr[m] === x), возвращается его индекс

Если элемент меньше искомого (sortedArr[m] < x), сдвигаем левую границу: l = m + 1

Если элемент больше искомого, сдвигаем правую границу: r = m - 1

Пример работы алгоритма
Рассмотрим на примере массива [1, 3, 5, 7, 9] и поиск числа 7:

Начальные границы: l = 0, r = 4

Середина: m = 2 ((0 + 4) >> 1 = 2)

sortedArr[2] = 5 — меньше 7, сдвигаем левую границу: l = 3

Новые границы: l = 3, r = 4

Середина: m = 3 ((3 + 4) >> 1 = 3)

sortedArr[3] = 7 — найдено, возвращаем индекс 3

Важные характеристики
Временная сложность: O(log n)

Требования: массив должен быть отсортирован

Результат: индекс найденного элемента или -1 при отсутствии

Преимущества:

Высокая эффективность для больших массивов

Минимальное количество операций

Постоянное уменьшение области поиска вдвое

Практическое применение
Бинарный поиск широко используется в:

Поиске данных в базах

Сортированных списках

Оптимизации алгоритмов

Системном
